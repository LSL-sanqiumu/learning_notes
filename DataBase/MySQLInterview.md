# MySQL

MySQL免费开源的关系型数据库管理系统。

字符集指的是一种从二进制编码到某类字符符号的映射。校对规则是指某种字符集下的排序规则。MySQL中每一种字符集都会对应一系列的校对规则。

MySQL采⽤的是类似继承的⽅式指定字符集的默认值，每个数据库以及每张数据表都有自己的默认值，他们逐层继承。比如：某个库中所有表的默认字符集将是该数据库所指定的字符集（这些表在没有指定字符集的情况下，才会采⽤默认字符集）。

## 存储引擎

### 常用命令

```mysql
show engines; -- 查看MySQL提供的所有存储引擎
show variables like '%storage_engine%'; -- 查看默认的存储引擎
show table status like 'table_name'; -- 查看表的存储引擎
show table status like "info"; -- 查看某个数据库中的某个表的使用的存储引擎（双引号包的是表名）
```

### MyISAM和Innodb的区别？

MySQL5.5版本后的默认存储引擎 Innodb。

1. Innodb支持事务、外键和行级锁、MVCC，而MyISAM不支持。
2. MyISAM支持全文索引，而Innodb不支持（Innodb 5.7版本之后也支持）。
3. Innodb下的表可以存储较多的数据。
4. MyISAM较小，节约空间，速度较快。
5. Innodb安全性高，支持高并发。

### Innodb引擎



## MySQL基础知识

### 1.MySQL的数据类型有哪些？

整数、浮点数、字符串、时间日期。

### 2.char、varchar、text的区别？

1. 都是用于存储字符。
2. char、varchar可以指定最大的字符长度，但text不可以。
   1. char(M)：M取值范围为0~255，指定最大字符长度M后，字符就不能超过M，但占用的空间仍然是M的字符所用的空间。字符最大长度为255。（定长的字符，指定多少就只能是多少，占不满的用空格填充）
   2. varchar(M)：M取值0~65532，此处的M也是指最大字符长度，指定后存储字符长度不能超过M，存储的值占用空间按字符实际使用的字节数确定，但不能超过65532字节。字符最大长度为0~65532。（字符长度可变，变化范围为0~M个字符）
3. 查询速度，text最慢。

### 3.SQL语句有哪几类。

1. DDL（数据定义语言）：对表、数据库的结构进行操作的，如create、drop、alter的都是。
2. DML（数据操作语言）：对表中数据进行操作的，如insert、update、delete。
3. DQL（数据查询语言）：用于查询表中数据的。
4. DCL（数据控制语言）：权限控制的。

### 4.SQL约束

1. 主键约束：表中记录的唯一标识，一个表只能有一个主键，可以是某一列或多列（复合主键），主键约束非空、唯一。
2. 唯一性约束：约束某列的值唯一、不重复，可以为null，null可重复。
3. 外键约束：用于建立两个表之间的联系，需要指定引用主表的哪一列。
4. 非空约束：不能为null。
5. 默认约束：默认值。
6. 检查约束：check约束会根据逻辑表达式来判断数据的有效性，以此来限制输入一行或多列的值的范围。更新的数据时，输入的内容必须满足check约束的条件。

### 5.子查询

子查询就是将一个查询的结果给另一个查询使用。

1. 标量子查询：子查询只返回一个值。（可以使用`>、<、>=、<=、<>`来和标量子查询的结果进行比较）
2. 列子查询：子查询只返回一列的数据。（得使用`in、any、some、all`等操作符，`select age1 from s1 where age1 > any (select age2 from s2) `）
3. 行子查询：返回某行数据。（`select * from user where (name,age)=(select name,age from user where name="lsl")`）
4. 表子查询：返回n行n列的数据。（`select * from user where (name,age) in (select name,age from user)`）

### 6.in、exists

in和exists一般用于子查询。

1. 使用exists时：先进行外表的查询，查询到结果再和内表查询的结果进行匹配；仅在内表查询中使用到索引。（`select id,name from tb_user where exists (select id,name from tb_user);`）
2. 使用in时：先进行内表的查询，然后对外表查询来匹配结果集，使用in()时在内表查询或外表查询中都会使用到索引。（如`select id,name from tb_user where id in(select id from tb_user);`，在内表中使用了索引）
3. 一般情况下，子查询结果集较大、外表较小时使用exists效率较高；子查询结果集小、外表较大是使用in效率较高。
4. not in和not exists：后者比前者效率高，与子查询结果集无关，只是因为not in 会对内外表都进行全表扫描，没有使用到索引，而not exists 的子查询则会使用到索引。

### 7.drop、delete、truncate的区别

1. drop：删除整个表，DDL，不可回滚。（快）
2. delete：逐行删除表中的数据，DML，可回滚。（慢）
3. truncate：删除表中全部数据，DDL，不可回滚。（较快）

### 8.union和union all的区别

1. union会对结果去重并排序。
2. union all直接合并结果，不去重不排序。
3. union all性能好。

### 9.临时表

MySQL在执行SQL语句时会创建一些存储中间结果集的表，这种表被称为临时表，临时表只对当前连接可见，在连接关闭后，临时表会被删除并释放空间。

临时表分类：内存临时表（使用MEMORY存储引擎）、磁盘临时表（使用的是MyISAM存储引擎））。

一般在以下情况中会使用到临时表：

1. from中的子查询。
2. distinct加上order by的查询。
3. order by 和 group by的字句不一样时会产生临时表。
4. 使用union查询会产生临时表。

### 10.大表数据查询的优化

索引优化、SQL语句优化、水平拆分、垂直拆分、建立中间表、使用缓存技术、固定长度的表访问起来更快、越小的列访问越快。

### 11.慢查询日志与优化

慢查询日志用于记录一些执行时间超过了临界值的SQL语句。

对慢查询进行优化：

1. 分析语句执行计划，索引是否命中。
2. 优化数据库的结构，将字段很多的表分解为多个表，或者考虑建立中间表。
3. 优化limit分页。

### 12.为什么要设置主键？

主键是用来区分每一行数据的唯一标识，没有主键可能会不能准确地标识某一行数据，那样更新或删除表中的特定的行就会有些困难。

### 13.主键一般使用自增ID还是UUID？

UUID：通用唯一标识码，是基于当前时间、计数器和硬件标识等数据计算生成的。

使用自增ID的优缺点：

1. 优点：字段长度较uuid小很多；数据库自动编号，按顺序存放，利于检索；无需担心主键重复问题。
2. 缺点：因为自增，在某些业务场景下容易被其他人查到业务量；发生数据迁移时、或表合并时会很麻烦；高并发场景下，竞争自增锁会降低数据库的吞吐能力。

使用UUID的优缺点：

1. 优点：标识唯一，不会考虑重复问题，在数据拆分、数据合并时也能达到全局的一致性；可以在应用层生成，提供数据库吞吐能力；无需担心业务量泄露的问题。
2. 缺点：UUID是随机生成的，因此会发生随机IO，影响插入速度，并且会造成硬盘的使用率降低；UUID之间进行大小的比较较自增ID之间的大小比较会慢不少，影响查询速度。

结论：一般情况下，MySQL推荐使用自增ID。因为在Innodb存储引擎中，注解索引是一种聚集索引，其B+树叶子节点按照顺序存储了主键值及数据，如果主键值是自增ID，只需要按顺序往后排即可，如果是UUID，因UUID是随机生成的，在数据插入时会造成大量的数据移动，产生大量的内存碎片，造成插入性能的下降。

### 14.字段为什么需要设置成not null？

注意null和空值不一样的，null需要占用空间而空值不需要，字段设置为not null后仍然可以插入空值。

字段设置为not null的主要原因：

1. null值会影响一些函数的统计，如count()。
2. B树不存储null，索引用不到null，会造成统计不到一些为null的数据。
3. not in() 子查询在有null值的情况下返回的结果都是null。
4. 在进行比较的时候，null的字段也会参与比较，因为null是一种比较特殊的数据类型，需要进行特殊的处理，这也就会增加数据库处理记录的复杂性。

### 15.如何优化查询过程中的数据访问？

1. 从减少数据访问方面考虑：正确使用索引，尽量做到索引覆盖；优化SQL执行计划。
2. 从返回更少数据方面考虑：数据分页处理；只返回需要的字段。
3. 从减少服务器CPU开销方面考虑：合理使用排序；减少比较操作；复杂运算在客户端处理。
4. 从增加资源方面考虑：客户端多进程并行访问；数据库并行处理。

### 16.如何优化长难的查询语句？

将一个大的查询分解为多个小查询；分解关联查询，使缓存效率更高。

### 17.如何优化limit分页？

在limit偏移量较大时查询效率会变低，可以记录每次取出的最大ID，下次查询时可以利用ID进行查询；建立复合索引。

### 18.如何优化union查询？

如果不需要对结果集进行去重或排序就使用union all。

### 19.如何优化where子句？

1. 不要在where子句中使用`!=、<>`进行不等于判断，这样会导致索引失效而走全表扫描。
2. 不要在where子句使用null或空值判断，尽量设置自动为not null。
3. 尽量使用union all代替or。
4. 在where和order by涉及的字段建立索引。
5. 尽量减少使用in或not in，会进行全部扫描。
6. 在where子句中使用参数会导致全部扫描。
7. 避免在where子句中对字段进行表达式或函数操作，会导致索引失效。

### 20.SQL语句执行很慢的原因？

1. 如果只是偶尔执行很慢，可能是执行中遇到了锁，也可能是redo log日志写满了，要将redo log中数据同步到磁盘中去。
2. 如果一直都很慢，可能是字段没加索引或者索引失效了。

### 21.SQL语句执行顺序

from ===> on ===> join ===> where ===> group by ===> having ===> select ===> distinct ===> order by。



## 索引

MySQL官方对索引的定义为：**索引（Index）是帮助MySQL高效获取数据的数据结构。**

MySQL支持多种索引（BTree索引、哈希索引、全文索引），平时使用最多的就是BTree索引（自平衡二叉树）。

索引实现原理：缩小扫描的范围，避免全表扫描。







## 缓存查询







## 事务







## 锁





## 数据库优化

### 1.大表任何优化？

1. 限定数据的范围：避免不带任何限制数据范围条件的查询语句。 
2. 读写分离：主库负责写，从库负责读。 
3. 垂直分表：将一个表按照字段分成多个表，每个表存储其中一部分字段。 
4. 水平分表：在同一个数据库内，把一个表的数据按照一定规则拆分到多个表中。
5. 对单表进行优化：对表中的字段、索引、查询SQL进行优化。 
6. 添加缓存。

### 2.什么是垂直分表、垂直分库、水平分表、水平分库？

垂直分表：将一个表按照字段分成多个表，每个表存储其中一部分字段。一般会将常用的字段放到一个 表中，将不常用的字段放到另一个表中。 

垂直分表的优势： 避免IO竞争减少锁表的概率。因为大的字段效率更低，第一数据量大，需要的读取时间长。第二， 大字段占用的空间更大，单页内存储的行数变少，会使得IO操作增多。 可以更好地提升热门数据的查询效率。 

垂直分库：按照业务对表进行分类，部署到不同的数据库上面，不同的数据库可以放到不同的服务器上 面。 

垂直分库的优势： 降低业务中的耦合，方便对不同的业务进行分级管理。 可以提升IO、数据库连接数、解决单机硬件资源的瓶颈问题。 

垂直拆分（分库、分表）的缺点： 主键出现冗余，需要管理冗余列 事务的处理变得复杂 仍然存在单表数据量过大的问题 

水平分表：在同一个数据库内，把同一个表的数据按照一定规则拆分到多个表中。 

水平分表的优势： 解决了单表数据量过大的问题 避免IO竞争并减少锁表的概率 水平分库：把同一个表的数据按照一定规则拆分到不同的数据库中，不同的数据库可以放到不同的服务 器上。 

 水平分库的优势： 解决了单库大数据量的瓶颈问题 IO冲突减少，锁的竞争减少，某个数据库出现问题不影响其他数据库（可用性），提高了系统的稳 定性和可用性 

水平拆分（分表、分库）的缺点： 分片事务一致性难以解决 跨节点JOIN性能差，逻辑会变得复杂 数据扩展难度大，不易维护 在系统设计时应根据业务耦合来确定垂直分库和垂直分表的方案，在数据访问压力不是特别大时应考虑 缓存、读写分离等方法，若数据量很大，或持续增长可考虑水平分库分表，水平拆分所涉及的逻辑比较 复杂，常见的方案有客户端架构和恶代理架构。





## 数据库连接池







## 高性能MySQL







