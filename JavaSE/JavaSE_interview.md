# JavaSE面试题

## 基础

### 概念题

#### **1.Java 语⾔有哪些特点?**  

Java语言简单易学，是一门面向对象的语言，具体体现为封装、继承、多态；其诞生就是为了简化网络编程而设计的，就是说有网络编程上的便利性；其可靠、安全，支持多线程；编译与解释并存，大大地提高了运行速度；平台无关性，。

#### **2.JVM、JDK 和 JRE。**

- JDK，Java开发工具包，包含了JRE和Java开发工具集（java.exe（运行）、javac.exe（编译）、javadoc.exe等），
- JRE，Java运行时环境，由JVM（Java Virtual Machine，Java虚拟机）和JavaSE标准类库组成，其作用是加载、验证并执行字节码文件。
- JVM，Java虚拟机，是运⾏ Java 字节码的虚拟机。 JVM 有针对不同系统的特定实现，⽬的是使⽤相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语⾔“⼀次编译，随处可以运⾏”的关键所在。  

#### **3.字节码文件是什么？使用字节码的好处有哪些？**

在 Java 中， JVM 可以理解的代码就叫做 字节码 （即扩展名为 .class 的⽂件），它不⾯向任何特定的处理器，只⾯向虚拟机。 Java 语⾔通过字节码的⽅式，在⼀定程度上解决了传统解释型语⾔执⾏效率低的问题，同时⼜保留了解释型语⾔可移植的特点。所以 Java 程序运⾏时⽐较⾼效，⽽且由于字节码并不针对哪⼀种特定的机器，因此Java 程序⽆须重新编译便可在多种不同操作系统的计算机上运⾏。  

#### **4.描述一下Java 程序从源代码到运⾏中的过程。**

编译：使用JDK中的开发工具（javac.exe）来将Java源代码编译为字节码文件。

运行：JVM类加载器加载字节码文件，然后通过解释器解释执行。后来使用JIT编译器，....

#### **5.Oracle JDK 和 OpenJDK 的对⽐**  

- OpenJDK 是⼀个参考模型，并且是完全开源的，⽽ Oracle JDK 是 OpenJDK7 的⼀个实现，并不是完全开源的。
- Oracle JDK ⽐ OpenJDK 更稳定。 OpenJDK 和 Oracle JDK 的代码⼏乎相同，但 Oracle JDK 有更多的类和⼀些错误修复。因此，如果您想开发企业/商业软件，建议选择 Oracle JDK，因为它经过了彻底的测试，并且稳定性更好。某些情况下，有些⼈提到在使⽤ OpenJDK 可能会遇到了许多应⽤程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决这个问题。
- 在响应性和 JVM 性能⽅⾯， Oracle JDK 与 OpenJDK 相比提供了更好的性能。
- Oracle JDK 不会为即将发布的版本提供长期⽀持，⽤户每次都必须通过更新到最新版本获得⽀持。
- Oracle JDK 根据⼆进制代码许可协议获得许可，⽽ OpenJDK 根据 GPL v2 许可获得许可 。

#### **6.Java 和 C++的区别?**  

- 都是面向对象的语言，都支持封装、继承、多态。
- Java 不提供指针来直接访问内存，程序内存更加安全。
- Java 的类是单继承的，使用接口概念来替代了C++中的多重继承； C++ ⽀持多重继承。  
- Java有自动内存管理机制，不需要程序员手动释放无用内存。

#### **7.Java程序的主类，应用程序和小程序的主类的区别。**

主类是Java程序执行的入口点，每个Java程序都必须有且只有一个主类。在Java应用程序中，主类是指包含main()方法的类，这个主类不一定是public的；而在Java小程序中，主类是继承自系统类JApplet或Applet的子类，其主类必须是public的。Java语言规范，main()方法必须声明为public，JDK1.4后，强制main()方法是public的。

#### **8.Java应用程序和小程序。**

- applat小程序没有main()方法，主要是嵌在浏览器⻚⾯上运⾏(调⽤ init() 或者 run() 来启动)，嵌⼊浏览器这点跟 flash 的小游戏类似。
- 应用程序从主线程启动。  

### 对思想的理解

#### **面向对象和面向过程的区别？**

- 面向过程：通常面向过程性能比面向对象高。因为 Java 是半编译语⾔，最终的执⾏代码并不是可以直接被 CPU 执⾏的⼆进制机械码，Java中类调用的时候类需要实例化，内存开销较大，比较消耗资源；而面向过程语言大多都是直接编译成机械码在电脑上执行，因此Java。但是，面向过程没有面向对象易维护、易复用、易拓展。
- ⾯向对象 ： ⾯向对象易维护、易复⽤、易扩展。 因为⾯向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使得系统更加灵活、更加易于维护。但是， 面向对象性能可能会比面向过程低。  

#### **谈谈你对面向对象的理解**

### 基本数据类型

#### **1.基本数据类型的自动提升。**

byte、char、short ===> int ===> long ===> float ===> double。

#### **2.自动装箱与自动拆箱。**

- 装箱：将基本数据类型用它们对应的应用类型包装起来。
- 拆箱：将包装类型转换为基本数据类型。



### 字符串

#### **1.字符型常量和字符串常量的区别？**

- 字符型常量是单引号引起单个字符，相当于一个ASCII值，可以参加表达式运算，只占2字节内存。
- 字符串常量是由双引号引起的多个字符，字符串常量代表一个地址值，占若干个字节的内存。

#### **2.String 为什么是不可变的?String、StringBuffer 和 StringBuilder 的区别是什么? **

可变不可变：

String类中使用char型数组来存储字符串，该字符类型使用final关键字修饰，所以String对象不可变（引用地址不变）。（JDK9之后，String使用byte类型数组来存储字符串）

String StringBuffer 和 StringBuilder都是使用字符数组来保存字符串，但没有使用final关键字来修饰，因此是可变的。

三者的线程安全性：

String是不可变的，可理解为常量，线程安全。StringBuffer中对方法加了同步锁或对调用的方法加了同步锁，因此线程安全。StringBuilder 没有对方法进行加同步锁，线程不安全。

三者性能：

每次对 String 类型进⾏改变的时候，都会⽣成⼀个新的 String 对象，然后将指针指向新的 String对象。 StringBuffer 每次都会对 StringBuffer 对象本身进⾏操作，⽽不是⽣成新的对象并改变对象引⽤。相同情况下使⽤ StringBuilder 相⽐使⽤ StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的⻛险。  

三者使用总结：

1. 操作少量数据，就使用String。
2. 单线程操作字符串，缓冲区下操作大量数据：使用StringBuilder。
3. 多线程操作字符串，缓冲区下操作大量数据：使用StringBuffer。



## 面向对象和类

### 1.构造器能被重写吗？

构造器不能被重写，但是可以构成重载。

### 2.重载与重写的区别？

重载：一个类中允许存在一个或多个同名方法，前提是它们的参数个数、类型、或顺序不一致，方法和返回值可以不同，可以有static关键字。（重载就是同⼀个类中多个同名⽅法根据不同的传参来执⾏不同的逻辑处理）

重写：重写发⽣在运⾏期，是⼦类对⽗类的允许访问的⽅法的实现过程进⾏重新编写，重写要求如下：

- 返回值类型、⽅法名、参数列表必须相同，抛出的异常范围⼩于等于⽗类，访问修饰符范围⼤于等于⽗类。
- 如果⽗类⽅法访问修饰符为 private/final/static 则⼦类就不能重写该⽅法，但是被 static修饰的⽅法能够被再次声明。  
- 构造方法不能被重写。
- （重写就是⼦类对⽗类⽅法的重新改造，外部样⼦不能改变，内部逻辑可以改变 ）

### 3.面向对象三大特性：封装、继承、多态。

封装：封装把⼀个对象的属性私有化，同时提供⼀些可以被外界访问的属性的⽅法，如果属性不想被外界访问，我们⼤可不必提供⽅法给外界访问。但是如果⼀个类没有提供给外界访问的⽅法，那么这个类也没有什么意义了。  

继承：继承是使⽤已存在的类的定义作为基础来建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以⽤父类的功能，但不能选择性地继承⽗类。通过使用继承我们能够非常⽅便地复⽤以前的代码。关于继承：

1. 子类拥有父类对象所有的属性和⽅法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是⽆法访问， 只是拥有。  
2. 子类可以拥有自己的属性和方法，也就是说子类可以对父类进行拓展。
3. 子类可以用自己的方式来实现父类的方法。  

多态：所谓多态就是指程序中定义的引⽤变量所指向的具体类型和通过该引⽤变量发出的⽅法调⽤在编程时并不确定，⽽是在程序运⾏期间才确定，即⼀个引⽤变量到底会指向哪个类的实例对象，该引⽤变量发出的⽅法调⽤到底是哪个类中实现的⽅法，必须在由程序运⾏期间才能决定。

在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。

### 4.在一个静态方法内调用一个非静态成员为什么是非法的?

静态方法不通过对象来调用，因此在静态方法里，不能调用其他的非静态变量、非静态成员变量。

### 5.定义空参构造器的作用。

Java 程序在执行子类的构造方法之前，如果没有⽤ super() 来调⽤父类特定的构造⽅法，则会调⽤父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，⽽在⼦类的构造方法中⼜没有用 super() 来调⽤父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执⾏。解决办法是在父类⾥加上⼀个不做事且没有参数的构造⽅法。 

### 6.接口和抽象类的区别。

1. 接口的⽅法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。
2. 接口中除了 static、 final 变量，不能有其他变量，⽽抽象类中则不⼀定。
3. ⼀个类可以实现多个接口，但只能实现⼀个抽象类。接口⾃⼰本身可以通过 extends 关键字扩展多个接⼝。
4. 接口⽅法默认修饰符是 public，抽象⽅法可以有 public、 protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用private 关键字修饰！）。
5. 从设计层⾯来说，抽象是对类的抽象，是⼀种模板设计，而接口是对行为的抽象，是一种行为的规范。  

总结⼀下 jdk7~jdk9 Java 中接⼝概念的变化（相关阅读）：

- 在 jdk 7 或更早版本中，接⼝⾥⾯只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。
- jdk8 的时候接⼝可以有默认方法和静态方法功能。
- Jdk 9 在接⼝中引入了私有方法和私有静态方法。  

### 7.成员变量和局部变量的区别。

1. 语法形式上：
   - 成员变量：属于类，可使用权限修饰符、static、final等来修饰。
   - 局部变量：方法中定义的参数或是方法的形参，不能被权限修饰符、static修饰，但可以被final修饰。
2. 存储方式上：
   - 成员变量：如果被static修饰，则是属于类的，没有使用static修饰则是属于对象实例的，对象存于堆内存；
   - 局部变量：如果其类型为基本数据类型，那么存储在栈内存中，如果为引用数据类型，那存放的是指向堆内存对象的引用或者是指向常量池中的地址。  
3. 从变量在内存的生存时间上看：
   - 成员变量是对象的一部分，随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
4. 成员变量如果没有被赋予初值，则会自动以类型的默认值赋值（final的必须显示赋值）；局部变量不会自动赋值。

### 8.创建对象使用什么运算符？对象实体与对象引用的不同。

创建对象使用new运算符。

对象实例在堆内存中，对象引用放在栈内存中；一个对象可以有多个对象引用，一个对象引用可以指向0个或1个对象。

### 9.什么是方法的返回值？返回值在类的方法里的作用是什么？

方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果（该方法会产生结果的话）。返回值的作用就是接收方法逻辑执行完成后的结果。

### 10.一个类的构造方法的作用是什么？若一个类没有声明构造方法会怎样？

主要作用是完成对类对象的初始化⼯作。

⼀个类没有声明构造方法的时候会有默认的无参构造方法。  

### 11.构造方法的特性有哪些。

- 方法名与类名相同。
- 没有返回值，不能用void声明构造参数。
- 生成类对象时自动执行，无需调用。

### 12.静态方法和实例方法有何不同？

1. 在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的⽅式。⽽实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。
2. 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态⽅法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。

### 13.对象的相等与指向他们的引用相等,两者有什么不同?

对象的相等，比较的是内存中存放的内容是否相等。⽽引用相等，⽐较的是他们指向的内存地址是否相等。  

### 14.在调用子类构造方法之前会先调用父类没有参数的构造⽅法，其目的是?

帮助子类做初始化工作。

### **15.==与equals()的区别**

==：比较运算符，用其来比较基本数据类型是比较的是值；比较引用数据类型时，比较的是对象的地址是否一致。

equals()：Object类的方法，只能用于判断对象是否相等，具体的比较由方法逻辑来决定，有以下情况：

1. 类没有重写该方法，此时是调用Object类的equals()方法，等价于使用==来比较对象。
2. 类重写了该方法，一般重写的逻辑都是用来比较两对象的内容（成员变量）是否相等，如果内容相同则认为是同一变量。

### **16.hashCode()和equals()**

hashCode()：

- hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回⼀个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。 
- hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java中的任何类都包含有 hashCode() 函数。
- 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速地检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）  

为什么要有hashCode()：

- 我们先以“HashSet 如何检查重复”为例⼦来说明为什么要有 hashCode： 当你把对象加⼊ HashSet时， HashSet 会先计算对象的 hashcode 值来判断对象加⼊的位置，同时也会与该位置其他已经加⼊的对象的 hashcode 值作⽐较，如果没有相符的 hashcode， HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调⽤ equals() ⽅法来检查 hashcode 相等的对象是否真  的相同。如果两者相同， HashSet 就不会让其加⼊操作成功。如果不同的话，就会重新散列到其他位置。（摘⾃我的 Java 启蒙书《Head first java》第⼆版）。
- 这样我们就⼤⼤减少了 equals 的次数，相应就⼤⼤提⾼了执⾏速度。通过我们可以看出： hashCode() 的作用就是获取哈希码，也称为散列码；它实际上是返回⼀个 int整数。这个哈希码的作⽤是确定该对象在哈希表中的索引位置。 hashCode() 在散列表中才有⽤，在其它情况下没⽤。在散列表中 hashCode() 的作⽤是获取对象的散列码，进⽽确定该对象在散列表中的位置。  

hashCode（）与 equals（）的相关规定  ：

- 如果两个对象相等，则 hashcode ⼀定也是相同的。
- 两个对象相等,对两个对象分别调⽤ equals ⽅法都返回 true。
- 两个对象有相同的 hashcode 值，它们也不⼀定是相等的。
- 因此， equals ⽅法被覆盖过，则 hashCode ⽅法也必须被覆盖。
-  hashCode() 的默认⾏为是对堆上的对象产⽣独特值。如果没有重写 hashCode()，则该 class的两个对象⽆论如何都不会相等（即使这两个对象指向相同的数据）。



## 集合



## JVM



